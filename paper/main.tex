\documentclass[12pt]{article}


% imports %
\usepackage[utf8]{inputenc}
\usepackage{biblatex}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{subfiles}
\usepackage[italian]{babel}
\usepackage{xcolor,listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{csquotes}
\usepackage{fancyvrb}
\usepackage{lipsum}
\usepackage{tikz}

\usepackage[a4paper,bindingoffset=0.2in,%
            left=1in,right=1in,top=1in,bottom=1in,%
            footskip=.25in]{geometry}
% end imports %

\addbibresource{references.bib}

\newcommand{\ExternalLink}{%
    \tikz[x=1.2ex, y=1.2ex, baseline=-0.05ex]{% 
        \begin{scope}[x=1ex, y=1ex]
            \clip (-0.1,-0.1) 
                --++ (-0, 1.2) 
                --++ (0.6, 0) 
                --++ (0, -0.6) 
                --++ (0.6, 0) 
                --++ (0, -1);
            \path[draw, 
                line width = 0.5, 
                rounded corners=0.5] 
                (0,0) rectangle (1,1);
        \end{scope}
        \path[draw, line width = 0.5] (0.5, 0.5) 
            -- (1, 1);
        \path[draw, line width = 0.5] (0.6, 1) 
            -- (1, 1) -- (1, 0.6);
        }
    }
    
% sql query styke %
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{HTML}{C42043}
\definecolor{backcolour}{HTML}{F2F2F2}
\definecolor{bookColor}{cmyk}{0,0,0,0.90}  

\lstset{upquote=true}

\lstdefinestyle{sql_style}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\numberstyle,
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
}
\lstset{style=sql_style}

\newcommand\numberstyle[1]{%
    \footnotesize
    \ttfamily
    \ifnum#1<10 0\fi#1 |%
}

% commands %
\renewcommand{\contentsname}{Contenuti}

% end commands%


\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \Huge
        Elaborato dell'esame di Stato \\\vspace{0.15cm} 'Tourm - Gestione audioguide'

        \vspace{1.5cm}

        \begin{center}
            \includegraphics[scale=0.08]{images/repubblica.png}
        \end{center}

        \normalsize
        Studente: Riccardo Calligaro, classe 5IA\\
        Relatori: Daniele Cappellazzo, Giancarlo Ronchi\\
        Tutor: Donatella Panciera

        \vfill

        ITIS C. Zuccante\
        A. S. 2020/2021\\\vspace{0.25cm}\LaTeX

    \end{center}
\end{titlepage}
\newgeometry{left=0.787402in,right=0.787402in,top=1in,bottom=1in}



\newpage

% start of document %
\newpage

\thispagestyle{plain}
\begin{center}
    \vfill
    \Huge
    \textbf{Abstract}
    \vspace{2cm}

\end{center}
\subfile{sections/abstract}
\vfill


% table of contents %
\newpage
\tableofcontents
\newpage
% end table of contents %

\section{Introduzione}
\subsection{Il progetto}
\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[width=7cm]{images/tourm_logo_transparent.png}
        \vspace{-2.7\baselineskip}
    \end{figure}
\end{center}

\textbf{Tourm} si propone di raggiungere i seguenti obiettivi:
\begin{itemize}
	\item sviluppare una \textbf{applicazione per smartphone}, disponibile sia su ambiente iOS che Android, destinata all’utente finale per consentirgli di:
	\begin{itemize}
	    \item scaricare l'applicazione attraverso un codice QR presente all'interno della villa
		\item accedere alla parte espositiva dell'applicazione con il codice del biglietto acquistato online o allo sportello di vendita.
		\item interagire con le esposizioni automatizzando la riproduzione di spiegazioni audio pre-registrate
		\item interagire con le esposizioni scannerizzando un codice QR che permette di leggere un articolo e ascoltare l'audioguida associata
		\item ricevere notifiche automatiche sulla disponibilità di visite guidate o eventi
	\end{itemize}
    \item sviluppare una \textbf{portale web amministrativo} destinato agli organizzatori per consentirgli di:
	\begin{itemize}
	    \item accedere al conteggio effettivo dei visitatori
		\item visualizzare statistiche riguardo le esposizioni e le interazioni fatte dagli utenti 
		\item chiudere o aprire l’accesso alle stanze
	\end{itemize}
    \item sviluppare un'\textbf{infrastruttura di rete} sicura, veloce e affidabile che permette ai visitatori di:
    \begin{itemize}
        \item collegarsi a una rete wireless gratuita senza accesso ad internet
        \item utilizzare l'applicazione senza nessun costo di dati mobili
        \item utilizzare la rete in modo sicuro senza doversi preoccupare di eventuali minacce
    \end{itemize}
    e ai gestori di: 
    \begin{itemize}
        \item utilizzare dei dispositivi specifici per accedere al pannello di amministrazione
    \end{itemize}
\end{itemize}

\clearpage

\subsection{Diagramma dei casi d'uso}
Gli \textbf{Use Case Diagram} (diagrammi dei casi d'uso) sono dei diagrammi dedicati alla descrizione delle funzioni o servizi offerti da un sistema, così come sono percepiti e utilizzati dagli attori che interagiscono col sistema stesso, aiutano a definire e organizzare i requisiti. \cite{use_case}
\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[width=6cm]{diagrams/usecase_diagrams_V2.png}
        \caption{Diagramma dei casi d'uso}
        \label{fig:usecase}
    \end{figure}
\end{center}

\subsection{WBS}
\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[width=14cm]{diagrams/elaborato_wbs_v2-wbs_V2_rev.png}
        \caption{Work Breakdown Structure}
        \label{fig:wbs}
    \end{figure}
\end{center}
\clearpage

\section{Infrastruttura di rete}
Avere un'infrastruttura di rete progettata in maniera efficace è di \textbf{fondamentale importanza}, tutte le operazioni quotidiane dipendono da essa. Quando si progetta un'infrastruttura non bisogna soltanto considerare la topologia di rete; è necessario infatti tenere conto anche di:
\begin{itemize}
    \item \textbf{dispositivi hardware}: server, datacenter, personal computer, router, switch; è importante fare delle scelte adatte e mirate al caso d'uso.
    \item \textbf{applicazioni e software}: applicazioni utilizzate dall'azienda, come web server, sistemi di gestione del contenuto e sistema operativo, ad esempio Linux. 
\end{itemize}

% \begin{itemize}
%     \item \textbf{Hardware}: include server, datacenter, personal computer, router, switch e altre dotazioni.
%     È da considerare parte dell'infrastruttura anche le strutture che ospitano il datacenter o che forniscono i sistemi di raffreddamento o alimentazione.
%     \item \textbf{Software}: si fa riferimento alle applicazioni utilizzate dall'azienda, come web server, sistemi di gestione del contenuto e sistema operativo, ad esempio Linux. Il sistema operativo gestisce le risorse di sistema e l'hardware e stabilisce inoltre tutte le connessioni necessarie fra i vari componenti software e le risorse fisiche che svolgono le operazioni.
%     \item \textbf{Rete}: l'interconnessione tra i componenti di rete consente l'esecuzione delle operazioni di rete, la gestione e la comunicazione tra i sistemi interni ed esterni. Per il funzionamento di una rete sono indispensabili la connessione a Internet, gli strumenti di attivazione, il firewall e la sicurezza, nonché l'hardware, ovvero router, switch e cavi
% \end{itemize}

Quali sono invece alcuni aspetti da considerare? 
\begin{itemize}
    \item \textbf{Efficienza}: creare un'infrastruttura di rete efficiente riduce al minimo i tempi di down e assicura la stabilità della rete.
    \item \textbf{Scalabilità}: una solida infrastruttura di rete supporta la crescita senza doverla riprogettare.
    \item \textbf{Sicurezza}: deve fornire sicurezza e protezione da spam, malware e virus. Deve anche mantenere i dati al sicuro.
    \item \textbf{Portata}: deve permettere agli utenti di essere connessi alla rete, indipendentemente dalla loro posizione.
\end{itemize}


% \subsection{Analisi dei requisiti}

% Tenendo a mente questi aspetti è ora possibile procedere con l'analisi della richiesta. Sarà necessario:
% \begin{itemize}
%     \item Hardware: fare delle scelte precise e mirate riguardo i \textbf{dispositivi} e le loro caratteristiche tecniche
%     \item predisporre un server che fornisce localmente a tutti i dispositivi collegati dei servizi usati dall'applicazione mobile scaricata dai visitatori. Questo server deve inoltre gestire il pannello di amministrazione.
%     \item progettare una \textbf{topologia di rete} con:
%       \begin{itemize}
%           \item una rete amministrativa per i computer gestionali. È necessario assicurarsi che soltanto i dispositivi di questa sottorete possono accedere al pannello di amministrazione e ad internet
%           \item una rete accessibile a tutti, che permette ai visitatori di connettersi da ogni parte del museo in modo \textbf{wireless}, assicurandosi che i dispositivi collegati al \textbf{Wi-Fi} non abbiano accesso a internet e al pannello di amministrazione
%           \item un \textbf{server} configurato in modo sicuro, accessibile soltanto dalla rete locale, che fornisce le API per far funzionare il client mobile
%       \end{itemize}
% \end{itemize}

\subfile{sections/infrastructure/beacons}

\subsection{Rete}
Il migliore modo per rappresentare la rete nel suo insieme è attraverso una \textbf{topologia}. Essa è una \textbf{mappa} che descrive i dispositivi e come sono collocati. Esistono due tipi di topologie:
\begin{itemize}
    \item \textbf{Topologia fisica}: indica la disposizione fisica dei dispositivi e dei mezzi trasmissivi
    \item \textbf{Topologia logica}: evidenzia il modo in cui gli host accedono al mezzo trasmissivo per inviare dati
\end{itemize}Essendo il luogo non definito, è impossibile realizzare la topologica fisica. Riguardo la topologia logica la maggior parte delle reti wireless utilizza una \textbf{topologia a stella}. Essa consiste in un nodo gateway (in questo caso un \textbf{Access Point}, AP) a cui tutti gli altri nodi si collegano. \cite{cisco} I vantaggi di questa scelta sono sicuramente:
\begin{itemize}
    \item prestazione della rete veloce e affidabile
    \item i nodi/dispositivi difettosi possono essere identificati e isolati rapidamente
\end{itemize}
Mentre gli svantaggi sono: 
\begin{itemize}
    \item la portata è limitata al raggio di trasmissione di un singolo dispositivo
    \item se il nodo gateway fallisce, l'intera rete smette di funzionare
\end{itemize}
\clearpage
Ai vari dispositivi dei visitatori è necessario aggiungere:
\begin{itemize}
    \item il \textbf{server}
    \item il \textbf{router}
    \item uno o più \textbf{switch}
    \item i vari \textbf{access point} a cui si collegano i dispositivi dei visitatori
\end{itemize}

\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[width=\textwidth]{diagrams/network_diagram_v3.png}
        \caption{Topologia logica}
        \label{fig:topologia_logica}
    \end{figure}
\end{center}

\subsection{Server}
Come server è stata utilizzata una \textbf{virutal machine} con \textbf{Ubuntu Server 21.04}, una distribuzione ufficiale di Ubuntu dedicata all'ambito server. La principale differenza con la distribuzione standard è l'ambiente desktop: mentre Ubuntu Desktop include un'interfaccia grafica utente, Ubuntu Server no. Inoltre la versione server include anche pacchetti standard che si concentrano principalmente su connettività e sicurezza.\cite{ubuntu_server_guide}.\\\\Per fornire le API è stato usato \textbf{\href{https://www.nginx.com/}{nginx}}, un web server/reverse proxy leggero ad alte prestazioni. Questa virtual machine è contenuta in un container \textbf{\href{https://www.docker.com/}{Docker}}, un sistema per l'automazione del deployment che considera i container come macchine virtuali modulari estremamente leggere, offrendo la flessibilità di creare, distribuire, copiare e spostare i container da un ambiente all'altro in modo sicuro.\cite{docker_guide}

\clearpage

\subsection{Uso delle API}
L'applicazione non accede direttamente al database, usa delle API. Creare un livello extra di astrazione non è solo utile per la sicurezza, ma anche per la scalabilità. 
\subsubsection{Cosa sono le API}
Un'API, interfaccia di programmazione di un’applicazione, è un insieme di comandi formalizzati che consentono alle applicazioni software di comunicare tra loro in modo uniforme e di sfruttare i servizi di base per creare servizi incentrati sul cliente. Quindi in questo caso il server esegue una applicazione che espone delle API che fanno comunicare il client Flutter con il database MySQL. 

\begin{center}
\begin{figure}[htp]
    \centering
    \includegraphics[width=12cm]{diagrams/diagramma_backend.png}
    \caption{L'interazione tra dispositivo, server e database}
    \label{fig:interazione_backend}
\end{figure}
\end{center}


\clearpage
\section{Il backend}
Il back-end, cioè la parte di ogni sito web o applicazione che gli utenti non vedono è composto da:
\begin{itemize}
    \item \textbf{server}: è il luogo in cui l'applicazione viene contenuta ed eseguita
    \item \textbf{applicazione}: l'applicazione che viene eseguita nel server, in questo caso si occupa di esporre delle API di tipo REST e di gestire il pannello di amministrazione
    \item \textbf{database}: la base dati, contiene tutti i dati necessari per l'utilizzo dell'applicazione  
\end{itemize}

\subsection{Il database}

Il database svolge una parte fondamentale di questa applicazione, per descriverlo ci sono vari metodi, qui si è scelto di trattare lo schema entità relazioni e quello logico. Come DBMS è stato usato MySQL.

\subsubsection{Schema E/R}
Lo schema E/R traduce le problematiche reali in uno  schema concettuale facilmente comprensibile, senza occuparsi di come sarà costruito il database.

\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[width=14cm]{diagrams/er_scheme_v2.png}
        \caption{Schema E/R}
        \label{fig:er}
    \end{figure}
\end{center}

\clearpage

\subsubsection{Schema logico}
L’obiettivo di questa fase è pervenire, a partire dallo schema concettuale, a uno schema logico che
lo rappresenti in modo fedele, “efficiente” e indipendente dal particolare DBMS adottato. Questo modello logico viene sviluppato anche per arricchire il modello concettuale visto precedentemente definendo esplicitamente le colonne di ogni entità e introducendo entità operative e transazionali.

\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[width=\textwidth]{diagrams/logic_scheme.png}
        \caption{Schema logico}
        \label{fig:logic_scheme}
    \end{figure}
\end{center}

\subsubsection{API in PHP}
Le API realizzate con il framework \textbf{Lumen} offrono vari endpoint che conformano allo stile \textbf{REST} (Representational state transfer). Alcuni di questi sono:
\begin{itemize}
    \item \verb+/api/v1/rooms+: lista delle stanze
    \item \verb+/api/v1/audioguides+: lista delle audioguide
    \item \verb+/api/v1/articles+: lista degli articoli
    \item \verb+/api/v1/audioguides/{beacon_id}+: audioguide per il beacon indicato
\end{itemize}
Questi restituiscono i dati ottenuti dal database con le query in formato \textbf{JSON}, un formato adatto all'interscambio di dati fra applicazioni client/server.
\subsubsection{Query SQL}
Per ottenere i dati il server esegue delle interrogazioni al database, di cui prima è stata descritta la struttura. Di seguito vengono riportate alcune query significative; i parametri vengono indicati con le parentesi graffe, nel codice PHP sono stati ineriti tramite PDO per evitare le SQL injection.\\\\\subfile{sections/backend/queries}

\section{Il client}
\subsection{App mobile}
L'applicazione viene scaricata dai visitatori attraverso un QRCode. Avviata
e inserito il codice presente nel biglietto, l’app viene impostata per la visita alla villa. Avviene poi l'interazione con i beacon bluetooth; quando l’app rileva che l'utente sta entrando nel range del trasmettitore avvisa il sistema che il visitatore è nella stanza e manda in esecuzione il commento audio. Quando l’app non percepisce più il beacon, avvisa  che l’utente è uscito e termina la presentazione.

\subsubsection{L'architettura del codice}
L’architettura di un sistema software è la “forma” data a quel sistema da coloro che la costruiscono. Per  “forma” si intende la divisione di tale sistema in componenti, nella disposizione di essi e nei modi in cui tali componenti comunicano tra loro. Lo scopo è  quello di facilitare lo sviluppo, la distribuzione, il funzionamento e la manutenzione del sistema software in esso contenuto.\cite{architettura_codice}
Come architettura è stato deciso di usare la \textbf{clean architecture}, il cui scopo principale è quello di permettere al business di adattarsi ai cambiamenti della tecnologia e delle interfacce cambiando il meno codice possibile. Aiuta a rimuovere quello stretto accoppiamento tra la logica di business e il livello di presentazione.\cite{architettura_introduction}\clearpage Questo tipo di architettura ha tre livelli principali:
\begin{itemize}
    \item \textbf{Presentazione}: contiene tutta la UI, si tratta principalmente di codice Flutter
    \item \textbf{Dominio:} è dove si definiscono le entità e i casi d'uso. Non vi sono classi concrete, solo interfacce (classi astratte). Tutte le implementazioni sono nel livello più sotto, il \emph{data} 
    \item \textbf{Data}: questo livello è responsabile di tutte le implementazioni dei casi d'uso e delle interfacce. Solitamente contiene classi per l'accesso ai dati del database o di una sorgente remota
\end{itemize}

\begin{center}
\begin{figure}[htp]
    \centering
    \includegraphics[height=10cm]{diagrams/clean_architecture.png}
    \caption{Lo schema della clean architecture}
    \label{fig:clean_architecture}
\end{figure}
\end{center}

\subsubsection{La gestione dello stato}
Un’applicazione non è mai del tutto statica e richiede in quasi tutti i casi di:
\begin{itemize}
	\item tracciare i cambiamenti
	\item dare l’opportunità all’utente di poter interagire con la UI
	\item aggiornare la UI dinamicamente in caso di cambiamenti nelle informazioni mostrate
\end{itemize}
Per gestire tutti questi aspetti in Flutter è possibile utilizzare una soluzione più elegante rispetto ai widget \emph{stateful}, il \textbf{BloC Pattern}. Questo pattern, che è implementato su Flutter con la libreria \emph{flutter\_bloc} permette di gestire il flow dell'applicazione tramite una stream di eventi.\clearpage
Di seguito è riportato il diagramma degli stati, una rappresentazione che descrive il comportamento dei sistemi analizzando gli stati, le transizioni e le azioni.

\begin{center}
    \begin{figure}[htp]
        \centering
        \includegraphics[height=11cm]{diagrams/state_diagrams_v2.png}
        \caption{Il diagramma degli stati}
        \label{fig:state_diagrans}
    \end{figure}
\end{center}
    

\subsection{Pannello di amministrazione web}
Il pannello di amministrazione permette di:
\begin{itemize}
    \item gestire la vendita dei biglietti
    \item osservare il conteggio effettivo dei visitatori
    \item chiudere o aprire l’accesso alle stanze
\end{itemize}
L'accesso è limitato, può essere visualizzato soltanto dallo staff. Per realizzarlo è stato usato il framework PHP \textbf{Laravel}. L'applicativo accede allo stesso database delle API Rest ma è totalmente separato in termini di codice. L'autenticazione avviene con Laravel Breeze.

\subfile{sections/frontend/admin_panel.tex}

\subfile{sections/security/security.tex}

\section{Considerazioni finali}
\subsection{Esperienza PCTO}
I moduli curriculari PCTO svolti durante i tre anni sono stati estremamente utili per la realizzazione di questo progetto; le competenze di \textbf{autoapprendimento} mi hanno aiutato a imparare ed utilizzare nuove tecnologie che non avevo mai usato, come ad esempio il framework \emph{Laravel}. Le competenze di \textbf{analisi di sistemi} mi hanno permesso di analizzare e risolvere con metodologia i vari problemi incontrati durante la realizzazione; infine l'attività svolta in quarta -\emph{Sviluppo App per Web e mobile}- ha arricchito notevolmente le mie competenze per quanto riguarda la creazione di un applicativo complesso e distribuito su più piattaforme.

\subsection{Risultati raggiunti e futuri miglioramenti}
Alla conclusione di questo elaborato, il cui obiettivo era quello di sviluppare una applicazione full-stack per semplificare notevolmente l'utilizzo delle audioguide, sia da parte dell'operatore che dell'utente finale, è possibile affermare che, sulla base dei test effettuati sulle funzionalità implementate, l'applicazione rappresenta un buon punto di partenza per lo sviluppo del prodotto finale. Alcune future funzionalità potrebbero comprendere:
\begin{itemize}
    \item aggiunta di un quiz per far interagire gli utenti con l'esposizione
    \item aggiunta di video o altri contenuti multimediali per comprendere meglio la spiegazione
    \item possibilità di maggiore personalizzazione dell'applicazione dal pannello di gestione
\end{itemize} 


\subsection{Conclusioni}


Il mobile computing è ogni giorno più presente nella nostra routine quotidiana. Questo può essere spiegato dalla grande evoluzione che si è verificata in questo settore nel corso dell'ultimo decennio e che ha causato l'emergere di una varietà di nuovi dispositivi mobili e sistemi operativi, sempre più sofisticati e potenti.  Attraverso l'internet of things è possibile collegare a questi dispositivi una miriade di gadget e scambiare informazioni, creando delle integrazioni che semplificano sempre di più la nostra vita quotidiana e migliorano le esperienze d'uso.

\section*{Collegamenti esterni}
\begin{itemize}
    \item Repository con codice sorgente frontend, backend e documento \LaTeX \hspace{0.17cm}\href{https://github.com/riccardocalligaro/tourm}{\ExternalLink}
\end{itemize}

\printbibliography



\end{document}

